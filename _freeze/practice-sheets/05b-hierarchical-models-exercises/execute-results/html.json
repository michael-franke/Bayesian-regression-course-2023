{
  "hash": "8130a306ea2be4837603663aa64e7594",
  "result": {
    "markdown": "---\ntitle: \"Bayesian regression: theory & practice\"\nsubtitle: \"05b: Hierarchical regression models (exercises)\"\nauthor: \"Michael Franke & Timo Roettger\"\nformat: html\neditor: visual\nexecute:\n  error: false\n  warning: false\n  message: false\ncallout-appearance: simple\n---\n\n\nLoad relevant packages and \"set the scene.\"\n\nHere is code to load (and if necessary, install) required packages, and to set some global options (for plotting and efficient fitting of Bayesian models).\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# install packages from CRAN (unless installed)\npckgs_needed <- c(\n  \"tidyverse\",\n  \"brms\",\n  \"remotes\",\n  \"tidybayes\",\n  \"bridgesampling\",\n  \"shinystan\"\n)\npckgs_installed <- installed.packages()[,\"Package\"]\npckgs_2_install <- pckgs_needed[!(pckgs_needed %in% pckgs_installed)]\nif(length(pckgs_2_install)) {\n  install.packages(pckgs_2_install)\n} \n\n# install additional packages from GitHub (unless installed)\nif (! \"aida\" %in% pckgs_installed) {\n  remotes::install_github(\"michael-franke/aida-package\")\n}\nif (! \"faintr\" %in% pckgs_installed) {\n  remotes::install_github(\"michael-franke/faintr\")\n}\nif (! \"cspplot\" %in% pckgs_installed) {\n  remotes::install_github(\"CogSciPrag/cspplot\")\n}\n\n# load the required packages\nx <- lapply(pckgs_needed, library, character.only = TRUE)\nlibrary(aida)\nlibrary(faintr)\nlibrary(cspplot)\n\n# these options help Stan run faster\noptions(mc.cores = parallel::detectCores())\n\n# use the CSP-theme for plotting\ntheme_set(theme_csp())\n\n# global color scheme from CSP\nproject_colors = cspplot::list_colors()[c(1,3,4,5,2,6:14),\"hex\", drop = TRUE]\n\n# setting theme colors globally\nscale_colour_discrete <- function(...) {\n  scale_colour_manual(..., values = project_colors)\n}\nscale_fill_discrete <- function(...) {\n   scale_fill_manual(..., values = project_colors)\n}\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphin <- aida::data_MT\nmy_scale <- function(x) c(scale(x))\n```\n:::\n\n\n## Exercise 1: Logistic regression\n\nConsider the following model formula for the `dolphin` data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrms::bf(MAD ~ condition + \n     (condition || subject_id) +\n     (condition || exemplar))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMAD ~ condition + (condition || subject_id) + (condition || exemplar) \n```\n:::\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n**Exercise 1a**\n\nWhy is the random effect structure of this model questionable? Can we meaningfully estimate all parameters? (Tip: Think about what group levels vary across predictor levels)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n# Answer: `condition` is not crossed with `exemplar`. An exemplar is either typical or atypical, thus a random slope does not make sense.\n```\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n**Exercise 1b**\n\nUse the following data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set up data frame\ndolphin_correct <- dolphin %>% \n  filter(correct == 1) %>% \n  mutate(log_RT_s = my_scale(log(RT)),\n         AUC_s = my_scale(AUC))\n```\n:::\n\n\nRun a multilevel model that predicts `AUC_s` based on `condition.` Specify maximal random effect structures for `exemplar`s and `subject_id`s (ignore correlations between intercepts and slopes for now). Specify a `seed = 98`.\n\nIf you encounter \"divergent transition\" warning, make them go away by refitting the model appropriately (Tip: Brms gives very useful, actionable advice)\n\n(This might take a couple of minutes, get used to it ;)\n:::\n\n\n::: {.cell warnings='false' messages='false' hash='05b-hierarchical-models-exercises_cache/html/exercise1b_a3883ed3a3732f88a62a1fc1b4cba287'}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n# refit with upped adapt_delta and max_treedepth\nxmdl_AUC2 <- brm(AUC_s ~ condition +\n                  (condition || subject_id) +\n                  (1 | exemplar),\n                data = dolphin_correct,\n                control=list(adapt_delta=0.99, max_treedepth=15), \n                seed = 98\n                )\nxmdl_AUC2\n```\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n**Exercise 1c**\n\nYou want to run a multilevel model that predicts `log_RT_s` based on `group`. You want to account for group-level variation of both `subject_id` and `exemplar`. What kind of groupings can be meaningfully estimated, given the dataset and the experimental design. You can check the crossing of different vectors with `xtabs()` for example.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n# check crossing\nxtabs(~ group + subject_id, dolphin_correct)\n# individual subject_ids contributed data only to one group because it is a between-subject design\n# --> we need varying intercepts only, i.e. a different base-rate for subjects\n\nxtabs(~ group + exemplar, dolphin_correct)\n# each exemplar contributes data to both groups\n# --> we can integrate varying intercepts and slopes for exemplars\n```\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n**Exercise 1d**\n\nRun a multilevel model that predicts `log_RT_s` based on `group` and add maximal random effect structures licensed by the experimental design (ignore possible random intercept-slope interactions for now).\n\nSpecify weakly informative priors as you see fit.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\npriors <- c(\n  #priors for all fixed effects (group)\n  set_prior(\"student_t(3, 0, 3)\", class = \"b\"),\n  #prior for the Intercept\n  set_prior(\"student_t(3, 0, 3)\", class = \"Intercept\"),\n  #prior for all SDs including the varying intercepts and slopes\n  set_prior(\"student_t(3, 0, 3)\", class = \"sd\")\n)\n\nxmdl <- brm(log_RT_s ~ group + \n              (1 | subject_id) +\n              (group || exemplar),\n            prior = priors,\n            data = dolphin_correct)\nxmdl\n```\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n**Exercise 1e**\n\nExtract the posterior means and 95% CrIs of touch vs. click `log_RT_s` and plot them.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n# Extract the posteriors\nposteriors <- xmdl %>%\n  spread_draws(b_Intercept, \n               b_grouptouch) %>%\n  # calculate posteriors for each individual level\n  mutate(click = b_Intercept,\n         touch = b_Intercept + b_grouptouch) %>% \n  select(click, touch) %>% \n  gather(key = \"parameter\", value = \"posterior\") %>% \n  group_by(parameter) %>% \n  summarise(mean_posterior = mean(posterior),\n            `95lowerCrI` = HDInterval::hdi(posterior, credMass = 0.95)[1],\n            `95higherCrI` = HDInterval::hdi(posterior, credMass = 0.95)[2])\n\n# plot\nggplot(data = posteriors, \n       aes(x = parameter, y = mean_posterior,\n           color = parameter, fill = parameter)) + \n  geom_errorbar(aes(ymin = `95lowerCrI`, ymax = `95higherCrI`),\n                width = 0.2, color = \"grey\") +\n  geom_line(aes(group = 1), color = \"black\") +\n  geom_point(size = 4) +\n  labs(x = \"group\",\n       y = \"posterior log(RT) (scaled)\")\n```\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n**Exercise 1f**\n\nAdd the posterior estimates for different `exemplar`s to the plot. (Tip: Check code from the previous \"tutorial\" to extract the random effect estimates.)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n# extract the random intercepts for exemplars\nrandom_intc_matrix <- ranef(xmdl)$exemplar[, , \"Intercept\"] %>% \n  round(digits = 2) \n\n# extract the by-exemplar random slopes for group\nrandom_slope_matrix <- ranef(xmdl)$exemplar[, , \"grouptouch\"] %>% \n  round(digits = 2)\n\n# random intercepts to dataframe\nrandom_intc_df <- data.frame(exemplar = row.names(random_intc_matrix), random_intc_matrix) %>% \n  select(exemplar, Estimate) %>% \n  rename(rintercept = Estimate)\n\n# combine with random slope matrix\nrandom_slope_df <- data.frame(exemplar = row.names(random_slope_matrix), random_slope_matrix) %>% \n  select(exemplar, Estimate) %>% \n  rename(rslope = Estimate) %>% \n  full_join(random_intc_df) %>% \n  # add population parameters and group-specific parameters\n  mutate(click_population = fixef(xmdl)[1],\n         touch_population = fixef(xmdl)[1] + fixef(xmdl)[2],\n         click = rintercept + click_population,\n         touch = rintercept + rslope + touch_population) %>% \n  select(exemplar, touch, click) %>% \n  gather(parameter, mean_posterior, -exemplar)\n  \n\n# combine with plot\nggplot(data = posteriors, \n       aes(x = parameter, y = mean_posterior,\n           color = parameter, fill = parameter)) + \n   # add random estimates\n  geom_point(data = random_slope_df, \n             alpha = 0.4,\n             size = 2,\n             position = position_jitter(width = 0.01)\n             ) +\n  # add lines between random estimates\n  geom_line(data = random_slope_df, \n            aes(group = exemplar),\n            color = \"grey\", alpha = 0.3) +\n  # add population-level estimates\n  geom_errorbar(aes(ymin = `95lowerCrI`, ymax = `95higherCrI`),\n                width = 0.2, color = \"grey\") +\n  geom_line(aes(group = 1), size = 2, color = \"black\") +\n  geom_point(size = 4, pch = 21, color = \"black\") +\n  labs(x = \"group\",\n       y = \"posterior log(RT) (scaled)\")\n```\n:::\n\n\n## Exercise 2: Poisson regression\n\n::: {.callout-caution collapse=\"true\"}\n**Exercise 2a**\n\nRun a multilevel poisson regression predicting `xpos_flips` based on `group`, `log_RT_s`, and their two-way interaction. Specify maximal random effect structures for `exemplar`s and `subject_id`s licensed by the design (ignore correlations between intercepts and slopes for now). (Tip: allow groupings to differ regarding the interaction effect if licensed by the design.) Specify weakly informative priors.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\npriors <- c(\n  #priors for all fixed effects\n  set_prior(\"student_t(3, 0, 3)\", class = \"b\"),\n  #prior for all SDs including the varying intercepts and slopes for both groupings\n  set_prior(\"student_t(3, 0, 3)\", class = \"sd\")\n)\n\npoisson_mdl <- brm(xpos_flips ~ group * log_RT_s +\n                     (log_RT_s || subject_id) +\n                     (group * log_RT_s || exemplar),\n                   data = dolphin_correct,\n                   prior = priors,\n                   family = \"poisson\")\n\npoisson_mdl\n```\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n**Exercise 2b**\n\nExtract and plot the population level estimates for both click and touch group as a regression line into a scatter plot (x = b_log_RT_s, y = xpos_flips).\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n# extract posterior means for model coefficients\npredicted_Poisson_values <- poisson_mdl %>%\n  spread_draws(b_Intercept, b_log_RT_s, \n               b_grouptouch, `b_grouptouch:log_RT_s`\n               ) %>%\n  # make a list of relevant value range of logRT\n  mutate(log_RT = list(seq(-5, 10, 0.5))) %>% \n  unnest(log_RT) %>%\n  mutate(click = exp(b_Intercept + b_log_RT_s*log_RT),\n         touch = exp(b_Intercept + b_log_RT_s*log_RT +\n                            b_grouptouch + `b_grouptouch:log_RT_s`*log_RT)) %>%\n  select(log_RT, click, touch) %>% \n  gather(group, posterior, -log_RT) %>% \n  group_by(log_RT, group) %>%\n  summarise(pred_m = mean(posterior, na.rm = TRUE),\n            pred_low = quantile(posterior, prob = 0.025),\n            pred_high = quantile(posterior, prob = 0.975)\n            ) \n\n# plot population level\nggplot(data = predicted_Poisson_values, aes(x = log_RT, y = pred_m)) +\n  geom_point(data = dolphin_correct, aes(x = log_RT_s, y = xpos_flips, color = group), \n             position = position_jitter(height = 0.2), alpha = 0.2) +\n  geom_line(aes(y = pred_m, color = group), size = 2) +\n  facet_grid(~group) +\n  ylab(\"Predicted prob of xflips\") +\n  ylim(-1,10) +\n  xlim(-5,10)\n```\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n**Exercise 2c**\n\nExtract the respective subject-specific estimates from the model and plot them into the same plot (use thinner lines).\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show solution\"}\n# extract the random effects for subject_id\n\n# intercepts\nrandom_intc_matrix <- ranef(poisson_mdl)$subject_id[, , \"Intercept\"] %>% \n  round(digits = 3)\n\n# slopes\nrandom_slope_matrix <- ranef(poisson_mdl)$subject_id[, , \"log_RT_s\"] %>% \n  round(digits = 3)\n\n# to df\nrandom_intc_df <- data.frame(subject_id = row.names(random_intc_matrix), random_intc_matrix) %>% \n  select(subject_id, Estimate) %>% \n  rename(rintercept = Estimate)\n\n# wrangle into one df \nrandom_slope_df <- data.frame(subject_id = row.names(random_slope_matrix), random_slope_matrix) %>% \n  select(subject_id, Estimate) %>% \n  rename(rslope = Estimate) %>% \n  full_join(random_intc_df) %>% \n  expand_grid(group = c(\"click\", \"touch\")) %>% \n  # add population parameters and group-specific parameters\n  mutate(adjusted_int = ifelse(group == \"click\",\n           rintercept + fixef(poisson_mdl)[1],\n           rintercept + fixef(poisson_mdl)[1] + fixef(poisson_mdl)[2]),\n         adjusted_slope = ifelse(group == \"click\",\n           rslope + fixef(poisson_mdl)[3],\n           rslope + fixef(poisson_mdl)[3] + fixef(poisson_mdl)[4])) %>% \n  mutate(log_RT = list(seq(-5, 10, 0.5))) %>% \n  unnest(log_RT) %>%\n  select(subject_id, log_RT, group, \n         adjusted_int, adjusted_slope) %>% \n  group_by(subject_id, log_RT, group) %>%\n  mutate(pred_m = exp(adjusted_int + adjusted_slope*log_RT))\n\n# plot the individual regression lines on top of the population estimate\nggplot(data = predicted_Poisson_values, aes(x = log_RT, y = pred_m)) +\n  geom_point(data = dolphin_correct, aes(x = log_RT_s, y = xpos_flips), \n             position = position_jitter(height = 0.2), alpha = 0.01) +\n  geom_line(aes(y = pred_m, color = group), size = 2) +\n  geom_line(data = random_slope_df, \n            aes(x = log_RT, y = pred_m, group = subject_id, color = group),\n            size = 0.5, alpha = 0.2) +\n  facet_grid(~group) +\n  ylab(\"Predicted prob of xflips\") +\n  ylim(-1,10) +\n  xlim(-5,10)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}